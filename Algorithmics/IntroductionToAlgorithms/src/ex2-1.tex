\documentclass{article}
    \usepackage[margin=0.7in]{geometry}
    \usepackage[parfill]{parskip}
    \usepackage[utf8]{inputenc}
    
    \usepackage{amsmath,amssymb,amsfonts,amsthm}
    \usepackage{algorithmic}
    %\floatname{algorithm}{Procedure}
    %\renewcommand{\algorithmicrequire}{\textbf{Input:}}
    %\renewcommand{\algorithmicensure}{\textbf{Output:}}

\title{Exercises 2.1}
\date{}
\author{}

\begin{document}

\maketitle
\section{2.1-2}

Rewrite the \textsc{Insertion-Sort} procedure to srot into ninincreasing instead of non-decreasing order.\\

\begin{algorithmic}
    \FOR{j = 2 \TO{\(A.length\)}}
        \STATE{\(key = A[j]\)}
        \STATE{\(i = j - 1\)}
        \WHILE{\(i > 0\) \AND\(A[i] < key\)}
            \STATE{\(A[i + 1] = A[i]\)}
            \STATE{\(i = i - 1\)}
        \ENDWHILE
    \STATE{\(A[i + 1] = key\)}
    \ENDFOR
\end{algorithmic}


\section{2.1-3}

Consider the \textit{\textbf{searching problem:}}\\

\textbf{Input:} A sequence of \(n\) numbers \(A = \langle a_1, a_2, \cdots, a_n \rangle\) and a value \(v\).\\
\textbf{Output:} An index \(i\) such that \(v = A[i]\) or the special value NIL if \(v\) does not appear in \(A\).

Write pseudocode for \textit{\textbf{linear search}}, which scans through the sequence, looking for \(v\). Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties.\\

\begin{algorithmic}
    \FOR{\(j = 1\) \TO{\(A.length\)}}
        \IF{\(A[j] = v\)}
            \RETURN{j}
        \ENDIF
    \ENDFOR
    \RETURN{NIL}
\end{algorithmic}

\textbf{Loop invariant:}\\
At the start of each iteration of the \textbf{for} loop, the subarray \(A[1\hdots j-1]\) doesn't contain the value of \(v\).

\textbf{Initialization:}\\
When \(j = 1\) the subarray \(A[1\hdots j - 1]\) contains no element and therefore doesn't contain the value \(v\).

\textbf{Maintenance:}\\
If the algorithm reaches the iteration \(n \leq A.length\) and that \(A[n] = v\) then the algorithm returns \(n\) and the algorithm transfers back to the point of call in the calling procedure. Therefore it never reaches the iteration \(n + 1\). So at the start of each iteration \(n + 1\) the subarray \(A[i\hdots n]\) doesn't contains the value \(v\).

\textbf{Termination:}\\
The \textbf{for} loop stops when \(j > A.length = n\). The \textbf{for} loop increasing \(j\) by one at each iteration, \(j = n + 1\) after the \textbf{for} loop. Substituting \(n + 1\) in the loop invariant, we have that the subarray \(A[1\hdots n]\) doesn't contains the value of \(v\). The subarray \(A[1\hdots n]\) being the whole array, the algorithm is correct.


\section{2.1-4}

Consider the problem of adding two \(n\)-bit binary integers, stored in two \(n\)-element arrays \(A\) and \(B\). The sum of the two intergers shoiuld be stored in binary form in an \((n + 1)\)-element array \(C\). State the problem formally and write pseudocode for adding the two integers.

\textbf{Input:} two \(n\)-element arrays A and B such that \(\forall i \in [0\cdots n],\ A[i] \in [0;1]\ and\ B[i] \in [0;1]\).\\
\textbf{Output:} an array \((n + 1)\)-element array \(C\) containing the binary sum of \(A\) and \(B\).\\

\begin{algorithmic}
    \STATE{\(C\) an array of size \(n + 1\)}
    \STATE{\(c = 0\)}
    \FOR{i \TO n}
        \STATE{\(s = A[i] + B[i] + c\)}
        \STATE{\(C[i] = (s \mod 2)\)}
        \STATE{\(c = div(s, 2)\)}
    \ENDFOR
    \STATE{\(C[n] = c\)}
\end{algorithmic}

\end{document}

